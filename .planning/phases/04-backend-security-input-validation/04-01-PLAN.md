---
phase: 04-backend-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/lib/api/helpers/auth_helpers.dart
  - backend/lib/api/helpers/permission_helpers.dart
  - backend/lib/api/fines_handler.dart
autonomous: true

must_haves:
  truths:
    - "isAdmin() uses only user_is_admin boolean flag, not user_role string"
    - "_createFine enforces fine_boss or admin permission via isFinesManager()"
    - "Fine endpoints operating on fineId without teamId (_approveFine, _rejectFine, _resolveAppeal, _recordPayment, _updateFineRule, _deleteFineRule) have TODO comments for future team-context permission enforcement"
    - "_createFineRule retains existing admin-only permission check"
    - "isFinesManager() helper checks user_is_admin OR user_is_fine_boss"
    - "Phase 2 input validation coverage confirmed — no handler passes raw body to service without parsing"
  artifacts:
    - path: "backend/lib/api/helpers/auth_helpers.dart"
      provides: "Consolidated isAdmin() using only boolean flag"
      contains: "user_is_admin"
    - path: "backend/lib/api/helpers/permission_helpers.dart"
      provides: "isFinesManager() and isCoachOrAdmin() permission helpers"
      exports: ["isFinesManager", "isCoachOrAdmin"]
    - path: "backend/lib/api/fines_handler.dart"
      provides: "Fine handler with isFinesManager() on _createFine and TODO comments on fineId-based endpoints"
      contains: "isFinesManager"
  key_links:
    - from: "backend/lib/api/fines_handler.dart"
      to: "backend/lib/api/helpers/permission_helpers.dart"
      via: "import and isFinesManager() calls"
      pattern: "isFinesManager\\(team\\)"
    - from: "backend/lib/api/helpers/permission_helpers.dart"
      to: "backend/lib/api/helpers/auth_helpers.dart"
      via: "shared team map convention"
      pattern: "user_is_admin.*user_is_fine_boss"
---

<objective>
Consolidate admin role checks and add fine_boss permission enforcement to all fine mutation endpoints.

Purpose: Eliminate dual-check inconsistency (user_is_admin vs user_role) that creates security ambiguity, and ensure all fine operations require proper authorization (fine_boss or admin role).

Output: Consolidated isAdmin() helper, new permission_helpers.dart with isFinesManager(), fines_handler.dart with permission checks on all mutation endpoints.
</objective>

<execution_context>
@/Users/karsten/.claude/get-shit-done/workflows/execute-plan.md
@/Users/karsten/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-backend-security-input-validation/04-RESEARCH.md

@backend/lib/api/helpers/auth_helpers.dart
@backend/lib/api/helpers/permission_helpers.dart
@backend/lib/api/fines_handler.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consolidate admin check and create permission helpers</name>
  <files>
    backend/lib/api/helpers/auth_helpers.dart
    backend/lib/api/helpers/permission_helpers.dart
  </files>
  <action>
1. In `backend/lib/api/helpers/auth_helpers.dart`, update `isAdmin()` to remove the backwards-compatibility OR check:

BEFORE:
```dart
bool isAdmin(Map<String, dynamic> team) {
  return team['user_is_admin'] == true || team['user_role'] == 'admin';
}
```

AFTER:
```dart
bool isAdmin(Map<String, dynamic> team) {
  return team['user_is_admin'] == true;
}
```

Update the doc comment to say: "Check if user has admin permissions using boolean flag system."
Remove the "(with backwards compatibility)" part.

2. Create new file `backend/lib/api/helpers/permission_helpers.dart` with:

```dart
/// Check if user can manage fines (admin or fine_boss).
bool isFinesManager(Map<String, dynamic> team) {
  return team['user_is_admin'] == true || team['user_is_fine_boss'] == true;
}

/// Check if user is a coach or admin.
bool isCoachOrAdmin(Map<String, dynamic> team) {
  return team['user_is_admin'] == true || team['user_is_coach'] == true;
}
```

No imports needed since these are pure functions operating on Map data.
  </action>
  <verify>
Run `dart analyze` from `/backend` directory. Verify zero errors.
Run `dart test` from `/backend` directory. Verify all 268 tests pass (isAdmin change should be transparent if data is consistent).
  </verify>
  <done>
isAdmin() uses only user_is_admin boolean flag. permission_helpers.dart exists with isFinesManager() and isCoachOrAdmin() helpers. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enforce fine_boss permission on all fine mutation endpoints</name>
  <files>
    backend/lib/api/fines_handler.dart
  </files>
  <action>
In `backend/lib/api/fines_handler.dart`:

1. Add import for permission helpers:
```dart
import 'helpers/permission_helpers.dart';
```

2. Add `isFinesManager(team)` check to ALL fine mutation endpoints that currently lack permission checks. The following endpoints need the check added AFTER the `requireTeamMember` check:

**_createFine** (line ~179): Currently has NO permission check. Add after team membership verification:
```dart
if (!isFinesManager(team)) {
  return resp.forbidden('Kun admin eller botesjef kan opprette boter');
}
```

**_approveFine** (line ~233): Currently has NO permission check (no team lookup at all). This needs a team lookup first. The fine's teamId must be retrieved to check membership. Since the current code doesn't look up the team, and adding a team lookup requires knowing the fine's team_id: Instead, add a comment noting this endpoint needs the fine's team context. For now, the fine service handles ownership at DB level. Skip this endpoint — it operates on a fineId without teamId context.

Actually, looking more carefully: _approveFine, _rejectFine, _resolveAppeal, and _recordPayment all operate on fineId/appealId without a teamId parameter. They cannot do team membership checks without first fetching the fine to get the teamId. This is a deeper refactor.

**Revised approach for fineId-based endpoints:** These 4 endpoints (_approveFine, _rejectFine, _resolveAppeal, _recordPayment) currently have NO team membership check OR permission check. They only verify the user is authenticated. For these endpoints:
- Do NOT add permission checks now (would require service-layer changes to fetch teamId from fineId first).
- The existing service layer handles authorization at the DB level.
- Add a `// TODO: Add team membership + fine_boss permission check (requires fine->teamId lookup)` comment to each.

**For endpoints that DO have teamId:**

**_createFine**: Add `isFinesManager(team)` check after the existing `requireTeamMember` check (around line 185, after the `if (team == null)` block).

**_createFineRule**: Already has `isAdmin(team)` check — this is correct (rules are admin-only config). No change needed.

**_updateFineRule** and **_deleteFineRule**: These operate on ruleId without teamId. Add TODO comment like above.

3. Verify the fine rule endpoints: `_createFineRule` already has `isAdmin(team)` — correct. `_updateFineRule` and `_deleteFineRule` need TODO comments for future team-context enforcement.

Summary of changes:
- Add `isFinesManager(team)` to `_createFine`
- Add TODO comments to `_approveFine`, `_rejectFine`, `_resolveAppeal`, `_recordPayment`, `_updateFineRule`, `_deleteFineRule`
- Import `permission_helpers.dart`
  </action>
  <verify>
Run `dart analyze` from `/backend` directory. Verify zero errors.
Run `dart test` from `/backend` directory. Verify all tests pass.
Grep for `isFinesManager` in fines_handler.dart to confirm it appears.
  </verify>
  <done>
_createFine enforces isFinesManager() permission. Fine rule creation remains admin-only. All fineId-based mutation endpoints have TODO comments for future team-context permission enforcement. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Phase 2 input validation coverage (Success Criteria #5)</name>
  <files>
    backend/lib/api/
  </files>
  <action>
Phase 2 (Type Safety & Validation) already migrated all 32 handler files and 34 service files to use parsing_helpers.dart, validation_helpers.dart, DateTime.tryParse(), and .firstOrNull guards. This task verifies that coverage is complete — it is NOT a rewrite.

1. Grep all handler files for patterns indicating raw body passed without validation:
   - `request.readAsString()` followed by `jsonDecode` without any parseString/parseInt/parseDateTime calls nearby
   - Direct `as String`, `as int`, `as Map` casts on JSON body fields (Phase 2 should have eliminated these)
   - `body['field']` used directly without null check or parse helper

   Run these checks:
   ```bash
   # Check for remaining unsafe casts in handlers
   grep -rn 'as String\|as int\|as Map\|as List\|as double\|as bool' backend/lib/api/ --include='*.dart' | grep -v 'test/' | grep -v '// safe' | grep -v 'toString()'

   # Check for raw body field access without parse helpers in handlers
   grep -rn "body\['" backend/lib/api/ --include='*_handler.dart' | grep -v 'parseString\|parseInt\|parseBool\|parseDateTime\|parseDouble\|parseList\|as Map<String, dynamic>\?' | head -30
   ```

2. If any gaps found (handler passing raw unvalidated body field to service), document them in the SUMMARY as "validation gaps found" with file:line references. These are candidates for Phase 7 (Code Consistency) cleanup.

3. If NO gaps found (expected outcome based on Phase 2's comprehensive work), document as "Phase 2 validation coverage confirmed complete — all handler inputs validated before reaching service layer."

This is a READ-ONLY verification task. Do NOT modify any handler files. Only document findings.
  </action>
  <verify>
The grep commands above return zero matches for unsafe casts in handler files, OR any matches are documented in the SUMMARY with rationale for why they are acceptable (e.g., already guarded, in test files).
  </verify>
  <done>
Verification sweep completed. Phase 2 input validation coverage confirmed (or gaps documented for Phase 7). Success Criteria #5 ("All handler inputs validated before reaching service layer") has evidence either confirming completion or identifying specific remaining gaps.
  </done>
</task>

</tasks>

<verification>
1. `cd backend && dart analyze` — zero errors, zero warnings related to security
2. `cd backend && dart test` — all 268 tests pass
3. `grep -n 'user_role' backend/lib/api/helpers/auth_helpers.dart` — returns zero matches (dual check removed)
4. `grep -n 'isFinesManager' backend/lib/api/fines_handler.dart` — returns at least 1 match
5. `cat backend/lib/api/helpers/permission_helpers.dart` — file exists with isFinesManager and isCoachOrAdmin
6. `grep -rn 'as String\|as int\|as Map' backend/lib/api/ --include='*_handler.dart'` — zero unsafe casts in handlers (Phase 2 coverage confirmed)
</verification>

<success_criteria>
- isAdmin() in auth_helpers.dart uses ONLY `user_is_admin == true` (no user_role fallback)
- permission_helpers.dart exists with isFinesManager() and isCoachOrAdmin()
- _createFine in fines_handler.dart enforces isFinesManager() check
- Fine rule creation remains admin-only via isAdmin()
- fineId-based mutation endpoints have TODO comments for future team-context enforcement
- Phase 2 input validation coverage verified — no handler passes raw body to service without validation
- All 268 backend tests pass
- `dart analyze` clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-backend-security-input-validation/04-01-SUMMARY.md`
</output>
