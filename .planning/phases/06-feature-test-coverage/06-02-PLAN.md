---
phase: 06-feature-test-coverage
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - backend/test/services/tournament_bracket_test.dart
  - backend/test/services/fine_service_test.dart
autonomous: true

must_haves:
  truths:
    - "Tournament bracket tests verify correct match count for 2, 3, 4, 5, 8, 16 participants"
    - "Tournament bracket tests verify all teams placed in first round"
    - "Tournament bracket tests verify walkover when odd participants (bye handling)"
    - "Tournament bracket tests verify bronze final creates extra round and match"
    - "Tournament bracket tests verify correct round names (Finale, Semifinale, Kvartfinale, 8-delsfinale)"
    - "Fine summary tests verify team summary calculations (total/paid/pending amounts)"
    - "Fine CRUD tests verify payment recording updates fine status to paid when fully paid"
    - "Fine CRUD tests verify partial payments don't change status"
    - "Fine CRUD tests verify appeal flow (create appeal, resolve accepted/rejected)"
  artifacts:
    - path: "backend/test/services/tournament_bracket_test.dart"
      provides: "Tournament bracket generation unit tests"
      min_lines: 150
    - path: "backend/test/services/fine_service_test.dart"
      provides: "Fine service unit tests covering CRUD, summaries, payments"
      min_lines: 200
  key_links:
    - from: "backend/test/services/tournament_bracket_test.dart"
      to: "backend/lib/services/tournament/tournament_bracket_service.dart"
      via: "mocktail mocks of TournamentCrudService, RoundsService, MatchesService, GroupService"
      pattern: "MockTournamentCrudService|MockTournamentRoundsService"
    - from: "backend/test/services/fine_service_test.dart"
      to: "backend/lib/services/fine/fine_crud_service.dart"
      via: "mocktail mock of Database + SupabaseClient + UserService"
      pattern: "MockDatabase|MockUserService"
---

<objective>
Create comprehensive unit tests for TournamentBracketService and fine services (FineCrudService + FineSummaryService).

Purpose: Tournament bracket generation has complex algorithms (calculating rounds, handling byes/walkovers, linking matches, bronze finals) that need parameterized testing across different participant counts. Fine services handle financial operations (payment recording, balance calculations, appeal workflows) where bugs can cause real-world payment issues.

Output: Two test files with 25+ test cases covering bracket generation algorithms and fine payment/summary logic.
</objective>

<execution_context>
@/Users/karsten/.claude/get-shit-done/workflows/execute-plan.md
@/Users/karsten/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/lib/services/tournament/tournament_bracket_service.dart
@backend/lib/services/tournament/tournament_crud_service.dart
@backend/lib/services/tournament/tournament_rounds_service.dart
@backend/lib/services/tournament/tournament_matches_service.dart
@backend/lib/services/fine/fine_crud_service.dart
@backend/lib/services/fine/fine_summary_service.dart
@backend/lib/db/database.dart
@backend/lib/db/supabase_client.dart
@backend/test/helpers/test_helpers.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tournament bracket generation tests</name>
  <files>backend/test/services/tournament_bracket_test.dart</files>
  <action>
Create `backend/test/services/tournament_bracket_test.dart` with comprehensive tests for TournamentBracketService.generateSingleEliminationBracket().

**Mocking approach:** TournamentBracketService depends on Database, TournamentCrudService, TournamentRoundsService, TournamentMatchesService, and TournamentGroupService. Mock all five via mocktail:
```dart
class MockDatabase extends Mock implements Database {}
class MockSupabaseClient extends Mock implements SupabaseClient {}
class MockTournamentCrudService extends Mock implements TournamentCrudService {}
class MockTournamentRoundsService extends Mock implements TournamentRoundsService {}
class MockTournamentMatchesService extends Mock implements TournamentMatchesService {}
class MockTournamentGroupService extends Mock implements TournamentGroupService {}
```

Wire up the service:
```dart
service = TournamentBracketService(db, crudService, roundsService, matchesService, groupService);
```

**Mock setup pattern for round creation:**
Use a counter to generate unique IDs:
```dart
var roundCounter = 0;
when(() => roundsService.createRound(
  tournamentId: any(named: 'tournamentId'),
  roundNumber: any(named: 'roundNumber'),
  roundName: any(named: 'roundName'),
  roundType: any(named: 'roundType'),
)).thenAnswer((invocation) async {
  roundCounter++;
  return TournamentRound(
    id: 'round-$roundCounter',
    tournamentId: 'tourn-1',
    roundNumber: invocation.namedArguments[#roundNumber] as int,
    roundName: invocation.namedArguments[#roundName] as String?,
    roundType: invocation.namedArguments[#roundType] as RoundType,
    status: MatchStatus.pending,
  );
});
```

**Mock setup for match creation:** Similar counter pattern, returning TournamentMatch with the provided teamAId/teamBId.

**Mock setup for setWalkover:** `when(() => matchesService.setWalkover(...)).thenAnswer((_) async {});`

**Mock setup for DB updates (winner_goes_to_match_id linking):** `when(() => client.update('tournament_matches', any(), filters: any(named: 'filters'))).thenAnswer((_) async => []);`

**Mock setup for updateTournamentStatus:** `when(() => crudService.updateTournamentStatus(any(), any())).thenAnswer((_) async => {});`

**Test groups:**

1. `_generateRoundNames` (test indirectly via bracket output):
   - 1 round (2 teams) → names: ['Finale']
   - 2 rounds (3-4 teams) → names: ['Semifinale', 'Finale']
   - 3 rounds (5-8 teams) → names: ['Kvartfinale', 'Semifinale', 'Finale']
   - 4 rounds (9-16 teams) → names: ['8-delsfinale', 'Kvartfinale', 'Semifinale', 'Finale']

2. `generateSingleEliminationBracket` parameterized tests:
   For each of [2, 3, 4, 5, 8, 16] participants:
   - Verify createRound called correct number of times
   - Verify all teams placed via createMatch calls in first round
   - Verify total match count = sum of matches across all rounds
   - Verify updateTournamentStatus called with TournamentStatus.inProgress

3. Bye handling (odd teams):
   - 3 teams: one match gets teamBId=null, setWalkover called for that match
   - 5 teams: verify byes assigned correctly

4. Bronze final:
   - 4 teams with bronzeFinal=true: extra round created with roundType=RoundType.bronze
   - 4 teams with bronzeFinal=true: total matches = 4 (2 semi + 1 final + 1 bronze)
   - getMatchesForRound called for semi-final round (to link losers to bronze)
   - bronzeFinal=false: no bronze round created

5. Match linking:
   - Verify winner_goes_to_match_id updates for round-to-round linking
   - Verify loser_goes_to_match_id for semi→bronze linking when bronzeFinal=true

**Important:** Register fallback values for any enums used in mock matchers:
```dart
setUpAll(() {
  registerFallbackValue(RoundType.winners);
  registerFallbackValue(TournamentStatus.inProgress);
  registerFallbackValue(MatchStatus.pending);
});
```
  </action>
  <verify>Run `cd "/Users/karsten/NextCore/Core - Idrett/backend" && dart test test/services/tournament_bracket_test.dart` — all tests pass.</verify>
  <done>Tournament bracket tests cover 2/3/4/5/8/16 participants, round naming, bye handling, bronze final, and match linking. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create fine service tests covering payments and summaries</name>
  <files>backend/test/services/fine_service_test.dart</files>
  <action>
Create `backend/test/services/fine_service_test.dart` with comprehensive tests for FineCrudService (payments, appeals) and FineSummaryService (team/user summaries).

**Mocking approach:** Both services use Database. FineCrudService also uses UserService. FineSummaryService uses UserService and TeamService.
```dart
class MockDatabase extends Mock implements Database {}
class MockSupabaseClient extends Mock implements SupabaseClient {}
class MockUserService extends Mock implements UserService {}
class MockTeamService extends Mock implements TeamService {}
```

**FineCrudService tests:**

1. `recordPayment` group:
   - Records payment and returns FinePayment object
   - Updates fine status to 'paid' when total payments >= fine amount (fully paid)
   - Does NOT update status when total payments < fine amount (partial payment)
   - Multiple partial payments: 30 + 40 on 100kr fine → status stays 'approved'; then +30 → status becomes 'paid'

   Mock pattern for recordPayment:
   - `client.insert('fine_payments', ...)` returns `[{'id': 'pay-1', 'fine_id': 'fine-1', 'amount': 50.0, ...}]`
   - `client.select('fines', filters: {'id': 'eq.fine-1'})` returns `[{'amount': 100.0}]`
   - `client.select('fine_payments', filters: {'fine_id': 'eq.fine-1'})` returns cumulative payments
   - `client.update('fines', {'status': 'paid'}, filters: ...)` only called when fully paid

2. `approveFine` group:
   - Approves pending fine → status becomes 'approved'
   - Returns null when fine not in 'pending' status

3. `rejectFine` group:
   - Rejects pending fine → status becomes 'rejected'
   - Returns null when fine not in 'pending' status

4. `createAppeal` group:
   - Creates appeal for 'approved' fine → fine status becomes 'appealed'
   - Returns null when fine not in 'approved' status

5. `resolveAppeal` group:
   - Accepted appeal → fine status becomes 'rejected' (fine dismissed)
   - Rejected appeal → fine status stays 'approved'
   - Rejected appeal with extraFee → fine amount increases by extraFee
   - Returns null when appeal not in 'pending' status

**FineSummaryService tests:**

1. `getTeamSummary` group:
   - Returns correct counts (fineCount, pendingCount, paidCount)
   - Calculates totalFines from only 'approved'/'appealed' fines (not pending/rejected)
   - Calculates totalPaid from fine_payments table
   - Returns zeros when team has no fines

2. `getUserSummaries` group:
   - Returns empty list when team has no members
   - Calculates per-user totals correctly
   - Includes payment totals per fine per user
   - Sorts by unpaid amount descending
   - Handles users with no fines (0 totals)

Mock patterns for FineSummaryService:
- `teamService.getTeamMemberUserIds(teamId)` returns user IDs
- `userService.getUserMap(userIds)` returns user details
- `client.select('fines', filters: {'team_id': ...})` returns fine rows
- `client.select('fine_payments', filters: {'fine_id': ...})` returns payment rows
  </action>
  <verify>Run `cd "/Users/karsten/NextCore/Core - Idrett/backend" && dart test test/services/fine_service_test.dart` — all tests pass.</verify>
  <done>Fine service tests cover payment recording (full/partial), appeal workflows (create/resolve), and summary calculations (team/user). All tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd "/Users/karsten/NextCore/Core - Idrett/backend"
dart test test/services/
dart test  # All existing tests still pass
```
</verification>

<success_criteria>
- Tournament bracket test file exists with 12+ tests covering 2/3/4/5/8/16 participants, bronze final, byes
- Fine service test file exists with 15+ tests covering payments, appeals, summaries
- Payment reconciliation tested (partial vs full payment status updates)
- All tests pass independently and alongside existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/06-feature-test-coverage/06-02-SUMMARY.md`
</output>
