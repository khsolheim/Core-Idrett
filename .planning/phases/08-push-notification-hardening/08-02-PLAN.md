---
phase: 08-push-notification-hardening
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - app/lib/features/notifications/providers/notification_provider.dart
autonomous: true

must_haves:
  truths:
    - "FCM token registration retries up to 8 times with exponential backoff on network/server errors"
    - "FCM token and last-sync timestamp are persisted locally after successful registration"
    - "On app restart, stale tokens (>24h) are automatically reregistered with the backend"
    - "Token registration errors are logged with context (platform, error type)"
    - "Token registration never blocks app startup or UI thread"
    - "On logout, both remote and local token data are cleaned up"
  artifacts:
    - path: "app/lib/features/notifications/providers/notification_provider.dart"
      provides: "Hardened FCM token management with retry, persistence, and error logging"
      contains: "RetryOptions"
  key_links:
    - from: "app/lib/features/notifications/providers/notification_provider.dart"
      to: "app/lib/features/notifications/data/notification_local_data_source.dart"
      via: "ref.watch(notificationLocalDataSourceProvider)"
      pattern: "notificationLocalDataSourceProvider"
    - from: "app/lib/features/notifications/providers/notification_provider.dart"
      to: "retry package"
      via: "RetryOptions.retry()"
      pattern: "retryOptions\\.retry"
---

<objective>
Rewrite FcmTokenNotifier to add exponential backoff retry on token registration, local token persistence via NotificationLocalDataSource, stale token recovery on startup, and structured error logging.

Purpose: The current implementation silently swallows registration failures and has no persistence or retry mechanism, meaning users can lose push notification capability until next app reinstall.

Output: A hardened notification_provider.dart that ensures reliable token delivery to the backend.
</objective>

<execution_context>
@/Users/karsten/.claude/get-shit-done/workflows/execute-plan.md
@/Users/karsten/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-push-notification-hardening/08-RESEARCH.md
@.planning/phases/08-push-notification-hardening/08-01-SUMMARY.md
@app/lib/features/notifications/providers/notification_provider.dart
@app/lib/features/notifications/data/notification_repository.dart
@app/lib/features/notifications/data/notification_local_data_source.dart
@app/lib/core/errors/app_exceptions.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry logic, local persistence, and error logging to FcmTokenNotifier</name>
  <files>app/lib/features/notifications/providers/notification_provider.dart</files>
  <action>
    Rewrite the `FcmTokenNotifier` class in `notification_provider.dart`. Keep the existing `notificationPreferencesProvider` and `NotificationPreferencesNotifier` unchanged.

    **Changes to FcmTokenNotifier:**

    1. **Add imports:**
    ```dart
    import 'dart:async';
    import 'package:flutter/foundation.dart';
    import 'package:retry/retry.dart';
    import '../data/notification_local_data_source.dart';
    ```

    2. **Add dependency on NotificationLocalDataSource:**
    ```dart
    late final NotificationLocalDataSource _localDataSource;
    ```
    Initialize in `build()`:
    ```dart
    _localDataSource = ref.watch(notificationLocalDataSourceProvider);
    ```

    3. **Replace `_registerToken` with retry-enabled version:**
    ```dart
    static const _retryOptions = RetryOptions(
      maxAttempts: 8,
      delayFactor: Duration(milliseconds: 400),
      randomizationFactor: 0.25,
      maxDelay: Duration(seconds: 60),
    );

    Future<void> _registerTokenWithRetry(String token) async {
      state = token;
      final platform = Platform.isIOS ? 'ios' : 'android';

      try {
        await _retryOptions.retry(
          () => _repo.registerToken(token: token, platform: platform),
          retryIf: (e) => _isRetryableError(e),
        );
        // Success: persist locally with timestamp
        await _localDataSource.saveToken(token, DateTime.now().toUtc());
      } catch (e) {
        // All retries exhausted — log error, persist token for next startup attempt
        _logRegistrationError(e, platform);
        // Still save token locally so we can retry on next startup
        await _localDataSource.saveToken(token, DateTime.fromMillisecondsSinceEpoch(0));
      }
    }
    ```

    4. **Add retry condition helper:**
    ```dart
    /// Determines if an error is retryable (network/server issues)
    /// Does NOT retry on 400/401/403/404 (client errors that won't change on retry)
    bool _isRetryableError(Exception e) {
      if (e is NetworkException) return true;
      if (e is TimeoutException) return true;
      if (e is ServerException) return true;
      if (e is ServiceUnavailableException) return true;
      // DioException wrapping — check inner error
      return false;
    }
    ```

    5. **Add structured error logging:**
    ```dart
    void _logRegistrationError(Object error, String platform) {
      if (kDebugMode) {
        print('[FCM] Token registration failed after ${_retryOptions.maxAttempts} attempts '
            '(platform: $platform, error: $error)');
      }
      // TODO: Send to error tracking service (Crashlytics) when integrated
    }
    ```

    6. **Add startup recovery for stale tokens:**
    Update `initialize()` to call recovery after setting up listeners:
    ```dart
    Future<void> initialize() async {
      if (_initialized) return;
      _initialized = true;

      final messaging = FirebaseMessaging.instance;

      // Request permission
      final settings = await messaging.requestPermission(
        alert: true,
        badge: true,
        sound: true,
        provisional: false,
      );

      if (settings.authorizationStatus == AuthorizationStatus.authorized ||
          settings.authorizationStatus == AuthorizationStatus.provisional) {
        // Get the token
        final token = await messaging.getToken();
        if (token != null) {
          // Fire-and-forget: don't block startup
          unawaited(_registerTokenWithRetry(token));
        }

        // Listen for token refresh
        messaging.onTokenRefresh.listen((token) {
          unawaited(_registerTokenWithRetry(token));
        }).onError((error) {
          _logRegistrationError(error, Platform.isIOS ? 'ios' : 'android');
        });

        // Check for stale local token and reregister if needed
        unawaited(_recoverStaleToken());
      }

      // Handle foreground messages (delegated to Plan 08-03)
      FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
    }
    ```

    7. **Add stale token recovery:**
    ```dart
    Future<void> _recoverStaleToken() async {
      try {
        if (await _localDataSource.needsReregistration()) {
          final (localToken, _) = await _localDataSource.getToken();
          if (localToken != null) {
            await _registerTokenWithRetry(localToken);
          }
        }
      } catch (e) {
        if (kDebugMode) {
          print('[FCM] Stale token recovery failed: $e');
        }
      }
    }
    ```

    8. **Update `removeToken()` to also clear local storage:**
    ```dart
    Future<void> removeToken() async {
      if (state != null) {
        try {
          await _repo.removeToken(state!);
        } catch (e) {
          // Ignore errors when removing token
        }
        state = null;
      }
      await _localDataSource.clearToken();
    }
    ```

    9. **Keep `_handleForegroundMessage` as-is** — Plan 08-03 will update it to use ForegroundNotificationService.

    **Important:** Use `unawaited()` from `dart:async` for fire-and-forget calls to make the intent explicit and avoid lint warnings. This ensures token registration never blocks the initialize() flow.
  </action>
  <verify>
    Run `cd "/Users/karsten/NextCore/Core - Idrett/app" && flutter analyze --no-fatal-infos 2>&1 | grep -E "error|warning" | head -20` — no new errors from our changes.
    Verify the file contains: RetryOptions, notificationLocalDataSourceProvider, _registerTokenWithRetry, _recoverStaleToken, _isRetryableError, _logRegistrationError, unawaited.
  </verify>
  <done>
    - FcmTokenNotifier uses RetryOptions with 8 attempts, 400ms-60s exponential backoff with jitter
    - Retry only on retryable errors (network, timeout, server) — not on client errors (400, 401, 403)
    - Token + timestamp persisted locally via NotificationLocalDataSource after successful registration
    - Failed registrations save token with epoch timestamp (0) to trigger reregistration on next startup
    - Stale token recovery runs on initialize() — reregisters if >24h since last sync
    - Token registration is fire-and-forget (unawaited) — never blocks app startup
    - Error logging includes platform and error context
    - removeToken() clears both remote and local token data
    - flutter analyze passes with no new errors
  </done>
</task>

</tasks>

<verification>
- `notification_provider.dart` compiles without errors
- RetryOptions configured with maxAttempts: 8, delayFactor: 400ms, maxDelay: 60s
- _isRetryableError returns true for NetworkException, TimeoutException, ServerException, ServiceUnavailableException
- _registerTokenWithRetry persists token on success and on failure (different timestamps)
- _recoverStaleToken checks needsReregistration() and reregisters if needed
- removeToken() calls _localDataSource.clearToken()
- All registration calls use unawaited() — no blocking
- flutter analyze passes
</verification>

<success_criteria>
FCM token registration retries with exponential backoff. Token persisted locally with timestamp. Stale tokens recovered on startup. Errors logged with context. Registration never blocks UI.
</success_criteria>

<output>
After completion, create `.planning/phases/08-push-notification-hardening/08-02-SUMMARY.md`
</output>
